<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Stock_Tracker Â· Samarth Paliwal</title>
  <meta name="theme-color" content="#070A12" />
  <link rel="stylesheet" href="../assets/site.css" />
</head>

<body>
  <main class="wrap">
    <header class="topbar">
      <div class="brand">
        <div class="mark"></div>
        <div class="brandText">
          <strong>Stock_Tracker</strong>
          <span>SWE Â· APIs Â· UI</span>
        </div>
      </div>

      <nav class="nav">
        <a class="chip" href="../projects.html">â† Projects</a>
        <a class="chip" href="../index.html">Home</a>
        <a class="chip" href="https://github.com/samarthpaliwal/Stock_Tracker" target="_blank" rel="noreferrer">Repo</a>
      </nav>
    </header>

    <section class="projectHero">
      <h1 class="pageTitle">ğŸ“ˆ Stock Tracker</h1>
      <p class="pageSub">A stock tracking app that turns API data into a usable interface.</p>
      <div class="thumb big">
        <img src="../assets/stock_tracker.png" alt="Stock_Tracker screenshot" />
      </div>
    </section>

    <section class="essay cardWide">
      <h2>How the code works (overview)</h2>
      <p>
        This project is built around a simple loop: accept a ticker symbol, fetch market data from
        an API, normalize the response, then render it in the UI. The â€œengineeringâ€ part is making
        that loop stable: handling bad inputs, network failures, rate limits, and inconsistent API
        payloads.
      </p>
      <p>
        Most implementations start with a UI component or a CLI entry point. The user provides a
        ticker, and the code validates it (non-empty, valid characters). Once validated, the app
        calls a data service function such as <span class="code">fetchQuote(ticker)</span>. This
        function builds a URL with query parameters, attaches the API key (often from environment
        variables), and sends an HTTP request.
      </p>
      <p>
        After receiving the response, the code parses JSON and converts it into a stable internal
        format. This step matters because APIs differ: some return numbers as strings, some use
        nested objects, and some omit fields. A good tracker uses safe access with defaults and
        converts values into numbers for comparisons and formatting.
      </p>
      <p>
        Once the data is normalized, the UI layer renders a â€œquote cardâ€ with price, daily change,
        and any extra fields like volume or open/high/low. If this is a React app, state management
        typically includes <span class="code">loading</span>, <span class="code">error</span>,
        and <span class="code">data</span>. The UI shows a skeleton/loader during requests, an
        error banner on failures, and the full card on success.
      </p>
      <p>
        If the project supports multiple tickers, it keeps an array of tracked symbols. Adding a
        symbol pushes into that list, and the app either fetches sequentially or in parallel using
        <span class="code">Promise.all</span>. A clean version separates â€œdata fetchingâ€ from
        â€œpresentationâ€ so UI components donâ€™t contain request logic.
      </p>
      <p>
        The code usually includes failure handling: if the API is down or returns a non-200 response,
        it sets an error state and renders a user-friendly message instead of crashing. Some versions
        also debounce input, so typing doesnâ€™t trigger repeated API calls.
      </p>
      <p>
        The end result is a small but realistic product slice: it treats external APIs as unreliable,
        keeps a stable internal data model, and builds UI states that reflect real-world conditions
        (loading, empty, error, success). That approach is what makes a tracker feel â€œfinishedâ€ rather
        than like a demo.
      </p>
    </section>

    <footer class="footer">
      <div>Â© <span id="y"></span> Samarth Paliwal</div>
    </footer>
  </main>

  <script src="../assets/site.js"></script>
  <script>setYear();</script>
</body>
</html>
