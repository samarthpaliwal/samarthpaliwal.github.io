<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>nova-ai Â· Samarth Paliwal</title>
  <meta name="theme-color" content="#070A12" />
  <link rel="stylesheet" href="../assets/site.css" />
</head>

<body>
  <main class="wrap">
    <header class="topbar">
      <div class="brand">
        <div class="mark"></div>
        <div class="brandText">
          <strong>nova-ai</strong>
          <span>Assistant Â· Product UX Â· Systems</span>
        </div>
      </div>

      <nav class="nav">
        <a class="chip" href="../projects.html">â† Projects</a>
        <a class="chip" href="../index.html">Home</a>
        <a class="chip" href="https://github.com/samarthpaliwal/nova-ai" target="_blank" rel="noreferrer">Repo</a>
      </nav>
    </header>

    <section class="projectHero">
      <h1 class="pageTitle">ğŸ¤– nova-ai</h1>
      <p class="pageSub">An assistant-style app designed for real usage, not just a demo.</p>
      <div class="thumb big">
        <img src="../assets/nova-ai.png" alt="nova-ai screenshot" />
      </div>
    </section>

    <section class="essay cardWide">
      <h2>How the code works (overview)</h2>
      <p>
        nova-ai is best thought of as a product shell around an assistant loop. The core loop is:
        accept user input â†’ build a request â†’ call an LLM (and tools if needed) â†’ render a structured
        response â†’ keep conversation history. The quality comes from how the code manages state and
        keeps the interface predictable.
      </p>
      <p>
        The frontend typically manages a message array that stores roles (user/assistant) and content.
        When a user submits a prompt, the app adds a user message immediately so the UI feels responsive.
        Then it enters a loading state and triggers a request to the backend API. That API call usually
        includes the current chat history so the model can respond in context.
      </p>
      <p>
        On the server side, the code exposes an endpoint like <span class="code">POST /chat</span>.
        It validates inputs, builds a prompt payload, and calls the model provider. If the assistant
        supports tools, the backend can interpret tool calls, execute them safely, then send tool outputs
        back into the model for a final answer. A clean architecture keeps tool execution isolated from
        the model call so you can audit what actions are allowed.
      </p>
      <p>
        The code also has to handle failure modes. Model calls can timeout, return incomplete answers,
        or produce low-confidence results. A good implementation returns a safe fallback message and keeps
        the UI stable. This is one reason to separate â€œtransport errorsâ€ (network, server) from â€œmodel
        quality issuesâ€ (uncertainty, missing info).
      </p>
      <p>
        On the UI side, nova-ai typically uses components for message bubbles, input bars, and optional
        panels (like settings or context). The UI is driven by state: messages, loading, error, and maybe
        a â€œmodeâ€ toggle. Keeping state minimal prevents bugs like duplicate messages or stuck spinners.
      </p>
      <p>
        If the assistant includes retrieval (RAG), the backend adds a retrieval stage before generating.
        It embeds the query, pulls relevant chunks from a store, and injects them into the prompt. That
        improves accuracy and makes answers less random. Strong versions also include an evaluation or
        logging layer to track prompts, outputs, and tool calls.
      </p>
      <p>
        Overall, nova-ai works because it treats the assistant as a system: UI + state + API boundaries +
        safe tool execution + optional retrieval. Thatâ€™s how you make an assistant that feels dependable
        when users rely on it repeatedly.
      </p>
    </section>

    <footer class="footer">
      <div>Â© <span id="y"></span> Samarth Paliwal</div>
    </footer>
  </main>

  <script src="../assets/site.js"></script>
  <script>setYear();</script>
</body>
</html>
